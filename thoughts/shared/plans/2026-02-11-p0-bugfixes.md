# P0 Bugfix Plan: Review Error Surfacing & Process Timeout

## Overview

Two P0 issues identified in the adversarial code review (`thoughts/shared/research/2026-02-11-adversarial-code-review-findings.md`) were audited on 2026-02-11 and confirmed as **still present** in the current codebase (post-PRManager decomposition).

| # | Issue | File | Lines | Severity |
|---|-------|------|-------|----------|
| 1 | Review PR fetch failure not surfaced to user | `Sources/PRManager.swift` | 210–218 | P0 |
| 2 | No timeout on `gh` process — app can hang indefinitely | `Sources/GitHubService.swift` | 364–402 | P0 |

## Smoke Test Confirmation (2026-02-11)

Both P0 issues were audited against the current codebase (post-PRManager decomposition, post-DRY cleanup, post-Swift Testing migration). Confirmed **still present**.

### Bug 1: Review PR Fetch Failure — CONFIRMED

- **File:** `Sources/PRManager.swift:215-218`
- **Evidence:** The review-PR failure path (line 215–218) executes `break` without setting `lastError`. The authored-PR failure path at line 204–207 does set `lastError`. When authored PRs succeed, `lastError` is cleared at line 203, and the subsequent review failure at line 215–218 does not re-set it.
- **Reproduction path:** If the GitHub API returns an error for review-requested PRs but succeeds for authored PRs, the user sees no error banner. The Reviews tab silently shows stale data from the last successful fetch.

### Bug 2: No Process Timeout — CONFIRMED

- **File:** `Sources/GitHubService.swift:364-402`
- **Evidence:** `process.waitUntilExit()` at line 396 blocks with no timeout. The `DispatchGroup` / `DispatchQueue.global().async` blocks at lines 383–394 are only for pipe draining — they do not implement any timeout. No `process.terminate()`, no `DispatchWorkItem`, no timer exists anywhere in the method.
- **Reproduction path:** If the `gh` CLI hangs (e.g., DNS stall, unresponsive GitHub API), the `Task.detached` thread in `refreshAll()` blocks indefinitely. `isRefreshing` stays `true`, the refresh guard at line 154 prevents future refreshes, and the app is permanently stuck.

## Current State Analysis

### Bug 1: Review PR Fetch Failure Silent

`refreshAll()` fetches authored PRs and review PRs in parallel. The authored-PR failure path correctly sets `lastError`. The review-PR failure path does **not** — it logs and `break`s:

```swift
// Sources/PRManager.swift:210-218
switch revPRs {
case .success(let prs):
    logger.info("refreshAll: review PRs fetched (\(prs.count) results)")
    reviewPRs = prs
case .failure(let error):
    logger.error("refreshAll: review PRs fetch failed: \(error.localizedDescription, privacy: .public)")
    // Keep existing reviewPRs in place — don't blank the UI
    break  // ← BUG: lastError never set
}
```

When authored PRs succeed (clearing `lastError` at line 203) and review PRs fail, the user sees **no error message** and the Reviews tab silently shows stale data.

### Bug 2: No Process Timeout

`GitHubService.run()` calls `process.waitUntilExit()` with no timeout:

```swift
// Sources/GitHubService.swift:396
process.waitUntilExit()
group.wait()
```

If `gh` hangs (DNS timeout, network issues, GitHub API stall), the calling thread blocks forever. Since `run()` is called from `Task.detached` blocks in `refreshAll()`, a hung process means a permanently stuck refresh with no recovery path.

## Desired End State

1. **When review PRs fail**, the user sees a distinct error message in the UI, regardless of whether authored PRs succeeded or failed.
2. **`gh` processes time out** after a configurable duration (default: 30 seconds) and are terminated, with a clear `GHError.timeout` surfaced to the caller.
3. **Existing tests still pass**, and new tests cover both fixes.

## What We're NOT Doing

- Not changing the parallel fetch architecture
- Not adding retry logic (separate concern)
- Not changing the UI layout for error display
- Not converting `GitHubService` to an actor (separate P1 issue)

---

## Phase 1: Surface Review PR Fetch Failures

**Goal:** Set `lastError` when review PRs fail, with a message that distinguishes it from authored-PR failures.

### 1.1 Fix the failure path in `refreshAll()`

**File:** `Sources/PRManager.swift`

Replace the review-PR failure `break` with `lastError` assignment. Handle the case where both fetches fail (concatenate messages):

```swift
// Process review-requested PRs — keep existing data on failure
switch revPRs {
case .success(let prs):
    logger.info("refreshAll: review PRs fetched (\(prs.count) results)")
    reviewPRs = prs
case .failure(let error):
    logger.error("refreshAll: review PRs fetch failed: \(error.localizedDescription, privacy: .public)")
    // Keep existing reviewPRs in place — don't blank the UI
    let reviewError = "Reviews: \(error.localizedDescription)"
    if let existing = lastError {
        lastError = "\(existing) | \(reviewError)"
    } else {
        lastError = reviewError
    }
}
```

**Design rationale:** If authored PRs also failed, `lastError` already contains that message from lines 204–207. We append the review error with a `|` separator so both failures are visible in the single-line error display. If only review PRs failed, the user sees just the review error.

### 1.2 Add test coverage

**File:** `Tests/PRManagerTests.swift` (existing test file)

Add three test cases using the existing `MockGitHubService`:

| Test | Setup | Expected |
|------|-------|----------|
| `testReviewPRFailureSetsLastError` | Authored succeeds, review throws | `lastError` contains "Reviews:" |
| `testBothFailuresCombinesErrors` | Both throw | `lastError` contains both messages separated by `\|` |
| `testReviewSuccessClearsReviewError` | After a review failure, next refresh both succeed | `lastError` is `nil` |

### 1.3 Manual verification

- [x] Build succeeds: `swift build 2>&1 | tail -5`
- [x] All tests pass: `swift test 2>&1 | tail -20`
- [x] Disconnect network, trigger refresh → error banner appears
- [ ] Reconnect, trigger refresh → error banner clears

---

## Phase 2: Add Process Timeout to `gh` Execution

**Goal:** Terminate `gh` if it hasn't exited within 30 seconds; surface a `GHError.timeout` error.

### 2.1 Add `GHError.timeout` case

**File:** `Sources/GitHubService.swift`

```swift
enum GHError: LocalizedError {
    case cliNotFound
    case apiError(String)
    case invalidJSON
    case timeout  // NEW

    var errorDescription: String? {
        switch self {
        case .cliNotFound:
            return "GitHub CLI (gh) not found — install it with: brew install gh"
        case .apiError(let msg):
            let trimmed = msg.trimmingCharacters(in: .whitespacesAndNewlines)
            return trimmed.isEmpty ? "GitHub API error" : trimmed
        case .invalidJSON:
            return "Invalid response from GitHub API"
        case .timeout:
            return "GitHub CLI timed out — check your network connection"
        }
    }
}
```

### 2.2 Replace `waitUntilExit()` with a timed wait

**File:** `Sources/GitHubService.swift`, `run()` method

Replace the blocking `process.waitUntilExit()` + `group.wait()` with a `DispatchSemaphore`-based timeout:

```swift
private static let processTimeout: TimeInterval = 30

private func run(_ arguments: [String]) throws -> (stdout: String, stderr: String, exitCode: Int32) {
    let process = Process()
    process.executableURL = URL(fileURLWithPath: ghPath)
    process.arguments = arguments

    let outPipe = Pipe()
    let errPipe = Pipe()
    process.standardOutput = outPipe
    process.standardError = errPipe

    do {
        try process.run()
    } catch {
        throw GHError.cliNotFound
    }

    // Drain both pipes concurrently to prevent pipe-buffer deadlock
    var outData = Data()
    var errData = Data()
    let group = DispatchGroup()

    group.enter()
    DispatchQueue.global().async {
        outData = outPipe.fileHandleForReading.readDataToEndOfFile()
        group.leave()
    }
    group.enter()
    DispatchQueue.global().async {
        errData = errPipe.fileHandleForReading.readDataToEndOfFile()
        group.leave()
    }

    // Wait for process with timeout instead of blocking indefinitely
    let semaphore = DispatchSemaphore(value: 0)
    process.terminationHandler = { _ in
        semaphore.signal()
    }

    let result = semaphore.wait(timeout: .now() + Self.processTimeout)
    if result == .timedOut {
        logger.error("run: gh process timed out after \(Self.processTimeout)s, terminating")
        process.terminate()
        // Give it a moment to clean up, then force-kill if needed
        DispatchQueue.global().asyncAfter(deadline: .now() + 2) {
            if process.isRunning { process.terminate() }
        }
        throw GHError.timeout
    }

    // Process exited normally — wait for pipes to finish draining
    group.wait()

    let stdout = String(data: outData, encoding: .utf8) ?? ""
    let stderr = String(data: errData, encoding: .utf8) ?? ""
    return (stdout, stderr, process.terminationStatus)
}
```

**Design rationale:**
- `DispatchSemaphore` + `terminationHandler` avoids blocking on `waitUntilExit()` while still providing a clean wait.
- 30-second timeout is generous enough for slow connections but prevents indefinite hangs.
- `process.terminate()` sends SIGTERM; the 2-second follow-up ensures cleanup.
- Pipe drain threads will unblock once the process is terminated (EOF on pipes).
- The timeout is a `static let` so it's easy to find and adjust.

### 2.3 Update the protocol (no change needed)

`GitHubServiceProtocol` methods already declare `throws`, so `GHError.timeout` is naturally propagated. No protocol changes required.

### 2.4 Add test coverage

**File:** `Tests/GitHubServiceTests.swift` (new or existing)

Since `GitHubService.run()` is private and spawns real processes, testing the timeout requires either:

**(a) Integration test** — Create a test that calls a method on `GitHubService` pointing at a script that sleeps longer than the timeout:

| Test | Setup | Expected |
|------|-------|----------|
| `testProcessTimeoutThrowsError` | Override `ghPath` to a script that `sleep 60`s | `GHError.timeout` thrown within ~32 seconds |

**(b) Verify through PRManager** — Using `MockGitHubService`, simulate a timeout by throwing `GHError.timeout`:

| Test | Setup | Expected |
|------|-------|----------|
| `testTimeoutErrorSurfacedToUser` | Mock throws `GHError.timeout` | `lastError` contains "timed out" |

Approach (b) is simpler and tests the error propagation. Approach (a) is an optional integration test for CI.

### 2.5 Manual verification

- [x] Build succeeds: `swift build 2>&1 | tail -5`
- [x] All tests pass: `swift test 2>&1 | tail -20`
- [ ] Simulate timeout: temporarily set `processTimeout = 1` and run a refresh → error appears within ~3 seconds
- [ ] Restore `processTimeout = 30`

---

## Implementation Order

| Step | Phase | Est. Lines Changed | Risk |
|------|-------|--------------------|------|
| 1 | Phase 1.1 — Fix `lastError` in review failure path | ~8 | Low — isolated change |
| 2 | Phase 1.2 — Add tests | ~40 | Low |
| 3 | Phase 2.1 — Add `GHError.timeout` | ~4 | Low |
| 4 | Phase 2.2 — Replace `waitUntilExit()` | ~20 | Medium — concurrency change |
| 5 | Phase 2.4 — Add tests | ~30 | Low |
| 6 | Phase 3.1 — Update research docs | ~10 | Low — docs only |
| 7 | Phase 4.1–4.4 — Commit & push | 0 | Low |

Total estimated: ~110 lines changed/added across source, tests, and docs.

---

## Phase 3: Update Research Documents

**Goal:** Update the adversarial code review research to reflect that these P0 issues now have fixes, preventing future audits from flagging them as open.

### 3.1 Update `thoughts/shared/research/2026-02-11-adversarial-code-review-findings.md`

**Section 4.1 — Review PR Fetch Failure (line ~383):**

Add a resolution note after the existing `**Fix**:` line:

```markdown
> **Status**: Fixed in P0 bugfix plan (`thoughts/shared/plans/2026-02-11-p0-bugfixes.md`, Phase 1). `lastError` is now set on review-PR failure, with combined messaging when both fetches fail.
```

**Section 4.2 — No Timeout on `gh` Process (line ~403):**

Add a resolution note after the existing `**Fix**:` line:

```markdown
> **Status**: Fixed in P0 bugfix plan (`thoughts/shared/plans/2026-02-11-p0-bugfixes.md`, Phase 2). `run()` now uses `DispatchSemaphore` + `terminationHandler` with a 30-second timeout and `GHError.timeout`.
```

**Recommended Fix Order section (line ~610):**

Update Steps 2 and 3 to indicate completion:

- Step 2 ("Add process timeout to `GitHubService.run()`"): Prefix with ~~strikethrough~~ or add `✅ Done` marker
- Step 3 ("Propagate review PR errors"): Prefix with ~~strikethrough~~ or add `✅ Done` marker

**Frontmatter (line ~10):**

Update `last_updated` and `last_updated_by`:

```yaml
last_updated: 2026-02-11
last_updated_by: Blake McAnally
```

### 3.2 Verification

- [x] Research doc reflects fixes for issues 4.1 and 4.2
- [x] Fix order steps 2 and 3 are marked done
- [x] No other sections were accidentally modified

---

## Phase 4: Commit & Push

### 4.1 Commit the source changes (Phase 1 + Phase 2)

```bash
git add Sources/PRManager.swift Sources/GitHubService.swift
git commit -m "fix(p0): surface review-PR fetch errors and add gh process timeout

- Set lastError when review-PR fetch fails, with combined messaging
  when both authored and review fetches fail (PRManager.swift:210-218)
- Add 30s timeout to GitHubService.run() via DispatchSemaphore +
  terminationHandler; new GHError.timeout case (GitHubService.swift)
- Prevents silent stale data on Reviews tab and indefinite app hangs

Closes P0 issues from adversarial code review findings."
```

### 4.2 Commit the test additions (Phase 1.2 + Phase 2.4)

```bash
git add Tests/
git commit -m "test: add coverage for review-PR error surfacing and timeout propagation

- testReviewPRFailureSetsLastError
- testBothFailuresCombinesErrors
- testReviewSuccessClearsReviewError
- testTimeoutErrorSurfacedToUser"
```

### 4.3 Commit the research doc updates (Phase 3)

```bash
git add thoughts/
git commit -m "docs: mark P0 issues 4.1 and 4.2 as fixed in research findings

Update adversarial code review research to reflect fixes from
2026-02-11-p0-bugfixes plan. Mark fix-order steps 2 and 3 as done."
```

### 4.4 Push

```bash
git push origin HEAD
```

### 4.5 Verification

- [ ] `git log --oneline -4` shows three clean commits
- [ ] `git diff origin/main` shows no uncommitted changes
- [ ] Remote is up to date

---

## Verification Checklist

- [x] `swift build` — zero errors, zero warnings
- [x] `swift test` — all tests pass (existing + new)
- [x] SwiftLint passes: `swiftlint lint --strict`
- [x] Manual smoke test: normal refresh cycle works
- [x] Manual smoke test: error states display correctly
- [x] Research docs updated with fix status
- [x] All changes committed and pushed
